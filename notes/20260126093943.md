# Model properties for computed state in Django

Instead of scattering state checks across views and templates, put them on the model as `@property` methods. Self-documenting and DRY.

```python
from django.db import models

class States:
    DRAFT = "1"
    REVIEW = "2"
    APPROVED = "3"
    PUBLISHED = "4"

class Content(models.Model):
    state = models.CharField(max_length=1, default=States.DRAFT)

    @property
    def is_draft(self):
        return self.state == States.DRAFT

    @property
    def in_review(self):
        return self.state == States.REVIEW

    @property
    def is_approved(self):
        return self.state == States.APPROVED

    @property
    def published(self):
        return self.state == States.PUBLISHED

    @property
    def can_submit_for_review(self):
        return self.state in (States.DRAFT, States.APPROVED)

# In templates: {% if content.can_submit_for_review %}
# In views: if content.published: ...
```

No database columns neededâ€”just computed on access. Clean, testable, and the model becomes the single source of truth.

Be mindful of DB queries though, overloading a property with potentially expensive computations can lead to performance hits. In that case I would use a *method* instead to make this more explicit.

I did a video on this a while ago as well: Python @property decorator explained ->
https://www.youtube.com/watch?v=8BbngXWouzo

#django #cleancode
