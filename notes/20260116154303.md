# Live debugging with sys.remote_exec

TIL: Python 3.14 added a live debugging hook:

`sys.remote_exec(pid, script)`

It asks a running CPython process to execute a small debug script at the next safe point so you can peek at a stuck worker without a restart. ðŸ¤¯

Practical demo (see also code below) ->

Terminal 1:

python3.14 target.py
# PID: 6950

Terminal 2:

sudo python3.14 controller.py 6950
# (sudo needed on macOS)

Now the target keeps running, but youâ€™ll see debug output appear in Terminal 1 (live state + stack trace).

Caveats: runs on the targetâ€™s main thread (keep scripts lightweight), and donâ€™t name your script inspect.py (stdlib shadowing).

If you build tooling around this (profilers/debuggers), this can be a big one. ðŸ’¡ ðŸš€

```
# target.py
import os
import time

counter = 0
print("PID:", os.getpid())

while True:
    counter += 1
    time.sleep(1)

# remote_inspect.py
import __main__ as m
import traceback

print("counter =", m.counter)
traceback.print_stack(limit=6)

# controller.py
import sys
from pathlib import Path

pid = int(sys.argv[1])
sys.remote_exec(pid, str(Path("remote_inspect.py").resolve()))
```

#debugging
