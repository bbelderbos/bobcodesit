# retry decorator

I suggested a decorator in a code review today. ðŸ˜Ž

Decorators are a clean way to abstract repeated logic â€” enriching functions without touching their core behavior. ðŸ’¡

In this example, we retry a flaky HTTP service with timeout logic. No more clunky while + try/except + sleep scattered everywhere. ðŸ“ˆ

```
# /// script
# dependencies = [
#   "httpx",
# ]
# ///
from functools import wraps
import time

import httpx


def wait_for_service(*, attempts: int, delay: int):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(1, attempts + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt < attempts:
                        print(f"Retrying {func.__name__} (attempt {attempt}): {e}")
                        time.sleep(delay)
                    else:
                        raise RuntimeError(f"{func.__name__} timed out.") from e

        return wrapper

    return decorator


@wait_for_service(attempts=3, delay=2)
def check_httpbin():
    r = httpx.get("https://httpbin.org/status/503")
    r.raise_for_status()
    print("Service is ready!")


check_httpbin()

"""
Output:

Retrying check_httpbin (attempt 1): The read operation timed out
Retrying check_httpbin (attempt 2): The read operation timed out
Traceback (most recent call last):
...
RuntimeError: check_httpbin timed out.
"""
```

To add more flexibility, here's a more advanced retry decorator with exponential backoff:

```
import time
from functools import wraps, partial
import requests


def retry(func=None, *, times=3, wait=0.5, factor=2.0):
    if func is None:
        return partial(retry, times=times, wait=wait, factor=factor)

    @wraps(func)
    def wrapper(*args, **kwargs):
        attempt = 0
        while attempt < times:
            try:
                return func(*args, **kwargs)
            except Exception as exc:
                attempt += 1
                delay = wait * (factor ** (attempt - 1))
                print(
                    f"{func.__name__} failed: {exc} â€” retry {attempt}/{times} in {delay:.1f}s"
                )
                time.sleep(delay)
        print(f"Gave up after {times} attempts.")
        return None

    return wrapper


@retry(times=3, wait=0.5, factor=2.0)
def get(url: str):
    resp = requests.get(url, timeout=5)
    resp.raise_for_status()
    return resp


get("https://httpbin.org/status/200")  # ok
get("https://httpbin.org/status/404")  # retries with 0.5s, 1.0s, 2.0s delays
```

#decorator
