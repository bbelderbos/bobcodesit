# split an iterable into pairs

Need to split an iterable into pairs? Try slicing with a step!

Quickly pair up elements in a list using zip combined with slicing:

```
numbers = range(1, 11)
pairs = list(zip(numbers[::2], numbers[1::2]))
print(pairs)  # [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]
``

You can also use a generator function. This method can be particularly useful if you're dealing with very large iterables, as it doesn't require creating intermediate lists:

```
def chunk_pairs(iterable):
    """Yield successive non-overlapping pairs from the iterable."""
    iterator = iter(iterable)
    for first in iterator:
        try:
            second = next(iterator)
            yield (first, second)
        except StopIteration:
            return

numbers = range(1, 11)
pairs = list(chunk_pairs(numbers))
print(pairs)  # [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]
```

This function works by iterating over the provided iterable two elements at a time. It's efficient for large data sets because it doesn't create additional lists or slices. The StopIteration exception is used to gracefully handle iterables with an odd number of elements.

#slicing #generators
