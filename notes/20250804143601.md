# Context managers vs decorators

Sometimes I see @contextmanager code that could also be written as a decorator.

So why not just use a decorator?

Because a decorator wraps the entire function, while a context manager lets you wrap only a specific part.

Thatâ€™s ideal for managing resources or state within a block, giving you more fine-grained control.

Example below ðŸ‘‡

```
from contextlib import contextmanager
import time


@contextmanager
def skip_if_timeout(seconds, cleanup=None):
    start = time.time()
    yield
    elapsed = time.time() - start
    if elapsed > seconds:
        try:
            if cleanup:
                cleanup()
        finally:
            print(f"Test skipped: took {elapsed:.2f}s (> {seconds:.2f}s)")


def teardown():
    print("Cleaning up resources...")


def times_out():
    # Simulate a function that takes too long
    time.sleep(3)


# No decorator here â€” just wrapping a specific block in a context manager
def some_function():
    # some code ...
    with skip_if_timeout(2.0, cleanup=teardown):
        times_out()
    # more code ...


some_function()
```

Context manager source: https://grep.app/zzzeek/sqlalchemy/main/lib/sqlalchemy/testing/util.py?q=skip_if_timeout#L524

#contextmanager #decorator
