# from messy to clean numbers with `removeprefix` / `removesuffix`

With `removeprefix("$")` and `removesuffix(suffix)` you strip only what you *expect* to be there, then `float(cap) * multiplier` does the rest. Classic EAFP: try to parse, fall back to `0.0` when the data is junk.

Bite: https://pybitesplatform.com/bites/analyze-stock-data/

```
def _cap_str_to_mln_float(cap: str) -> float:
    """If cap = 'n/a' return 0, else:
       - strip off leading '$',
       - if 'M' in cap value, strip it off and return value as float,
       - if 'B', strip it off, multiply by 1,000 and return
         value as float"""
    if cap == "n/a":
        return 0
    cap = cap.strip().replace("$", "")
    if "M" in cap:
        return float(cap.replace("M", ""))
    elif "B" in cap:
        return float(cap.replace("B", "")) * 1000


# Refactored (omitting docstring)

def _cap_str_to_mln_float(cap: str) -> float:
    cap = cap.strip()
    if not cap or cap.lower() == "n/a":
        return 0.0

    suffix = cap[-1]
    multiplier = 1000.0 if suffix == "B" else 1.0

    try:
        cap = cap.removeprefix("$")
        if suffix in {"M", "B"}:
            cap = cap.removesuffix(suffix)
        return float(cap) * multiplier
    except ValueError:
        return 0.0


assert _cap_str_to_mln_float("$300M") == 300.0
assert _cap_str_to_mln_float("$1.2B") == 1200.0
assert _cap_str_to_mln_float("750M") == 750.0
assert _cap_str_to_mln_float("2.5B") == 2500.0
assert _cap_str_to_mln_float("n/a") == 0.0
assert _cap_str_to_mln_float("  $0.8B ") == 800.0
```

#strings
