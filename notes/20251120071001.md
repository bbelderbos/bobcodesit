# from messy to clean numbers with `removeprefix` / `removesuffix`

Rather than chaining string replaces, make the intent explicit: strip the input, handle `"n/a"` early, grab the last character as a suffix, and map `"B"` to a 1000x multiplier. With `removeprefix("$")` and `removesuffix(suffix)` you remove only what you *know* should be there, then `float(cap) * multiplier` does the rest. Itâ€™s a nice example of EAFP in practice: try to parse, fall back to `0.0` when the data is junk.

Bite: https://pybitesplatform.com/bites/analyze-stock-data/

```
def _cap_str_to_mln_float(cap: str) -> float:
    """If cap = 'n/a' return 0, else:
       - strip off leading '$',
       - if 'M' in cap value, strip it off and return value as float,
       - if 'B', strip it off, multiply by 1,000 and return
         value as float"""
    if cap == "n/a":
        return 0
    cap = cap.strip().replace("$", "")
    if "M" in cap:
        return float(cap.replace("M", ""))
    elif "B" in cap:
        return float(cap.replace("B", "")) * 1000


# Refactored (omitting docstring)

def _cap_str_to_mln_float(cap: str) -> float:
    cap = cap.strip()
    if not cap or cap.lower() == "n/a":
        return 0.0

    suffix = cap[-1]
    multiplier = 1000.0 if suffix == "B" else 1.0

    try:
        cap = cap.removeprefix("$")
        if suffix in {"M", "B"}:
            cap = cap.removesuffix(suffix)
        return float(cap) * multiplier
    except ValueError:
        return 0.0
```

#strings
