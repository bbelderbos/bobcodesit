# Dataclass config flags

Most devs stop at @dataclass. But stack these flags and you get production-grade data containers:

```python
from dataclasses import dataclass, field

@dataclass(frozen=True, slots=True, order=True, kw_only=True)
class Member:
    id: int
    name: str
    email: str = field(compare=False)
    level: int = 1

    def __post_init__(self):
        if self.level < 0:
            raise ValueError("Level cannot be negative")


m1 = Member(id=10, name="Alice", email="a@web.com")
m2 = Member(id=5, name="Bob", email="b@web.com")
m3 = Member(id=10, name="Alice", email="different@web.com")

# order=True: sortable by fields (id first, then name)
assert sorted([m1, m2]) == [m2, m1]

# frozen=True: immutable + hashable (works in sets/dict keys)
try:
    m1.level = 99
except AttributeError:
    pass  # Can't mutate frozen instance
assert m1 in {m1, m2}

# field(compare=False): email excluded from equality
assert m1 == m3  # Same id/name/level, different email

# slots=True: no __dict__ (smaller, faster)
assert not hasattr(m1, "__dict__")

# kw_only=True: positional args rejected
try:
    Member(1, "Test", "t@web.com")
except TypeError:
    pass  # Must use keyword arguments

# __post_init__: validation runs after init
try:
    Member(id=1, name="Bad", email="b@web.com", level=-1)
except ValueError:
    pass  # Caught invalid data early
```

Here are 5 features that help you write better data classes:

â€¢ `frozen=True` makes instances immutable (hey Rust ðŸ˜„). No accidental state mutations. Bonus: frozen objects are hashable, so they work in sets and as dict keys.

â€¢ `order=True` generates all comparison methods based on field order (hence `sorted()` just works on your objects).

â€¢ `__post_init__` runs after __init__. Perfect for validation or computing derived fields from the initialized data (if you stick with stdlib, of course here the upgrade to Pydantic is to be considered for more complex validation).

â€¢ `slots=True` removes the instance `__dict__`. Smaller memory footprint, faster attribute access.

â€¢ `kw_only=True` forces callers to use named arguments. *Explicit is better than implicit* and nice for backwards compatibility when adding fields later.

Especially the combo frozen=True + slots=True is a clean way to make clean, fast and immutable value objects. ðŸš€

#dataclasses
