# power of the right data structure: stacks

From ~9 seconds to ~0.1 secondsâ€¦ just by changing the data structure.

In a recent @Pybites code ensemble session we tackled an Advent of Code puzzle where you repeatedly â€œreactâ€ a polymer string by removing adjacent units like aA / Bb.

Our first solution kept iterating over the string and rebuilding it until it stopped changing. 

It workedâ€¦ but took almost 9 seconds.

When profiling code we saw:

...
78782697 4.851 0.000 4.851 0.000 {method 'swapcase' of 'str' objects}
78691470 3.541 0.000 3.541 0.000 {method 'append' of 'list' objects}
...

~80 million times Ã— â€œtiny costâ€ â‰ˆ many seconds ðŸ˜…

Then we rewrote it using a simple stack ðŸ‘‡

Same logic, single pass, no repeated string rebuilding.

New runtime? About 0.1 seconds. ðŸ”¥

Sometimes the biggest performance win isnâ€™t a faster language or clever micro-optimisation â€“ itâ€™s picking the right data structure. ðŸ’¡

```
def remove_matches(data: str) -> int:
    stack = []
    for c in data:
        if stack and c == stack[-1].swapcase():
            stack.pop()
        else:
            stack.append(c)
    return len(stack)
```

#ds
