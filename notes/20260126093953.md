# Prompt engineering patterns: config as data

Don't hardcode AI prompts and channel rules in your code. Store them as data structures so they're easy to tweak and extend.

```python
# Brand voice as reusable config
PYBITES_VOICE = """
- Friendly but professional
- Use "you" to address the reader directly
- Include one actionable takeaway
- Avoid jargon unless explaining it
"""

# Channel-specific rules as a dict
CHANNEL_CONFIG = {
    "linkedin": {
        "max_length": 3000,
        "tone": "professional, thought-leadership",
        "hashtags": 3,
    },
    "x": {
        "max_length": 280,
        "tone": "concise, punchy",
        "hashtags": 2,
    },
    "threads": {
        "max_length": 500,
        "tone": "casual, conversational",
        "hashtags": 0,
    },
}

def get_generation_prompt(channel: str, content: str) -> str:
    config = CHANNEL_CONFIG.get(channel, CHANNEL_CONFIG["linkedin"])
    return f"""
{PYBITES_VOICE}

Write a {channel} post. Max {config['max_length']} chars.
Tone: {config['tone']}
Include {config['hashtags']} hashtags.

Source content:
{content}
"""
```

Adding a new channel? One dict entry. Tweaking tone? Change one string. No code changes needed.

This is also know as the "dictionary dispatch pattern", where data structures drive behavior, see also this video:

Mastering Python Refactoring: Simplifying Code with the Dictionary Dispatch Pattern
https://www.youtube.com/watch?v=bL0Y-aEnlgY

#designpatterns
